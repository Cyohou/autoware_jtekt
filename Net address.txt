问题背景
你在 Autoware 中使用 /localization/pose_twist_fusion_filter/ekf_localizer。

EKF 经常报错：

コード
[EKF] current_ekf_pose_ out of bounds or non-finite, disabling EKF TF publish
导致 TF 停止发布，定位链路崩溃。

🔎 已确认的情况
EKF 订阅输入

/initialpose3d

/localization/pose_estimator/pose_with_covariance

/localization/twist_estimator/twist_with_covariance

消息检查

你贴出的 pose 与 initialpose3d 消息：对角协方差均为正，非对角虽有负值但合理。

没有 NaN/Inf，数值正常。

所以协方差本身不是直接污染源。

EKF 节点服务

确认存在 /localization/pose_twist_fusion_filter/trigger_node 可用于停启 EKF。

之前调用错误的服务名导致“waiting for service”，现已确认正确服务。

EKF 日志

报出极大数值（x≈10^12 甚至更大），说明 EKF 状态被污染。

这类数值通常来自：

输入消息中偶发的极端值或 NaN/Inf

时间/TF 不一致导致外推失败

问题现象
EKF 在运行过程中，第一次融合非零 twist 时，orientation 出现 NaN，导致 EKF 输出 pose 爆炸成天文数字。

日志中出现 [EKF] current_ekf_pose_ out of bounds or non-finite。

通过 rosbag 回放时，/pose、/twist 输入数据本身正常，但 EKF 输出突然失效。

二、逐层分析
1. 输入层（gyro_odometer）
负责将 IMU、车辆 twist、GNSS odometry 转换为 /twist_with_covariance。

问题：

有时输入的 covariance 为 0 或负数。

如果直接传给 EKF，会导致数值不稳定。

解决：

使用 guard_positive 等函数强制替换非法协方差。

增加 NaN/Inf 检查，丢弃非法输入。

2. EKF 内部（ekf_localizer）
负责融合 pose 与 twist，输出最终的 /pose、/twist。

问题：

四元数更新时没有强制归一化，浮点误差累积后可能直接 NaN。

过程噪声参数过小，EKF 过度相信 twist，导致发散。

解决：

在 predictKinematicsModel 和 measurementUpdateTwist 后强制四元数归一化。

更新后检查状态向量 X 是否包含 NaN/Inf，若有则丢弃该次更新。

调整参数：

proc_stddev_vx_c、proc_stddev_wz_c、proc_stddev_yaw_c 适当调大，避免过度收敛。

3. 初始化（pose_initializer）
负责发布 /initialpose3d，触发 EKF 初始化。

问题：

输出的 covariance 与 EKF 内部预期不一致，可能导致初始化后不稳定。

解决：

保证输出 covariance 与 EKF 初始化矩阵 P 一致，尤其是 yaw 的不确定度要足够大。

如果使用 GNSS 自动初始化，确保时间戳和 frame_id 与 EKF 一致。


解决：

如果 TF 查找失败，应丢弃该帧，而不是强行改 frame_id。

5. 运行时保护
EKF 在 timerTFCallback 中已经有位置越界检查。

需要进一步增加：

orientation 的有限性检查。

一旦检测到 NaN/Inf，立即停掉 EKF，等待重新初始化。

三、总结
要解决 EKF 爆炸的问题，需要从三个方面入手：

输入层过滤：gyro_odometer 严格检查并修正非法协方差、NaN/Inf。

EKF 内部防护：四元数归一化 + NaN 检查 + 合理的过程噪声参数。

初始化与外部模块一致性：pose_initializer 输出的 covariance 与 EKF 预期一致，ndt_scan_matcher 的 GNSS passthrough 严格处理 TF。

✅ 一句话总结： EKF 爆炸的根因是 数值稳定性不足 + 输入数据质量不一致。解决方案是 输入端过滤、EKF 内部归一化与检查、初始化与外部模块参数一致，三方面同时加强，才能彻底避免 NaN 和发散。
