1. 发现问题
一开始 /pose_twist_fusion_filter/twist 一直是 0，怀疑 EKF 没有融合 twist。

检查 /sensing/gnss/oxts_ins use_sim_time，发现虽然可以设成 True，但 GNSS odometry 的时间戳依然是录包时的实时时间（1747…），和 /clock 仿真时间域（1758…）不一致。

结论：时间域不一致 → EKF 延迟检查直接丢掉观测。

2. 验证时间戳问题
用 ros2 topic echo 对比 /sensing/gnss/ins/odometry 和 /clock，确认时间戳差了上千秒。

明确了问题根源：GNSS 驱动直接用设备时间填 header.stamp，回放时不会自动变成仿真时间。

3. 制定修复方案
决定先不改驱动源码，而是在回放链路中加一个时间戳重写节点（stamp_fixer）：

订阅 /sensing/gnss/ins/odometry

用 now()（受 use_sim_time 控制）重写 header.stamp

发布到新话题 /sensing/gnss/ins/odometry_fixed

让 EKF 改订阅这个 _fixed 话题。

4. 应用修复并验证
上线 stamp_fixer 后，/pose_twist_fusion_filter/twist 立刻恢复非零输出，速度和角速度随时间变化。

验证 /debug 话题，确认 twist 创新量稳定非零 → EKF 已经在融合 twist。

5. 发现新问题
对比 /pose_estimator/pose_with_covariance（直线轨迹）和 /pose_twist_fusion_filter/pose（大范围数值 + 姿态乱转圈），发现两者位置数值域差距巨大。

检查 TF，发现：

map 帧缺失或不可用

播放 bag 时 TF 时间戳是旧的（TF_OLD_DATA）

结论：坐标系不一致 + TF 不可用 → twist 方向被误解，姿态被拉偏。

6. 深入分析 GNSS passthrough
GNSS passthrough 直接把 GNSS odometry 的 pose 发布到 /pose_estimator/pose_with_covariance，并强行改成 frame_id=map，但没有做实际坐标变换。

这条链路内部自洽，所以轨迹看起来正常，但它的“map”并不是真正的 Autoware map。

7. 明确最终修复方向
时间域：保持 stamp_fixer，确保所有观测在 /clock 时间域。

坐标系：

GNSS pose 要么通过 TF（map→gnss_map）对齐到地图，要么数值平移到地图数值域。

Twist 要转换到 base_link 坐标系（静态 TF 或旋转计算）。

TF 树：回放时屏蔽 bag 里的 /tf，自己发布静态 TF，保证树结构完整且无 TF_OLD_DATA。

🎯 成果
已经让 EKF 能融合 twist，速度输出恢复正常。

明确了姿态乱转的根因：坐标系和 TF 不一致。

制定了完整的修复方案，下一步只要对齐坐标系 + 清理 TF，就能让 /pose_twist_fusion_filter/pose 和 /pose_estimator/pose_with_covariance 在同一数值域、轨迹平滑。
